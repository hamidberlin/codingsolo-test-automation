ğŸ“‚ Grundstruktur:
XPath navigiert durch die XML- oder HTML-Struktur mithilfe von Pfadelementen und Achsen.
//tagname[@attribut='wert']

ğŸ“Œ Grundlegende Selektoren:
Ausdruck						Bedeutung
/								Absoluter Pfad (ab Wurzelknoten)
//								Relativer Pfad (Ã¼berall im Dokument suchen)	
.								Aktueller Knoten
..								Elternknoten
@								Attribut auswÃ¤hlen (@class, @id)
ğŸ“Œ Beispiele:
XPath	Beschreibung
/html/body/div					Selektiert direkt das <div>-Element im Body
//div							Selektiert alle <div>-Elemente im Dokument
//div[@class='test']			Selektiert <div> mit class="test"
//*[@id='main']					Jedes Element mit id="main"
//input[@type='text']			Alle input-Felder mit type="text"
//a[text()='Home']				Link mit exakt dem Text "Home"

ğŸ“Œ XPath-Funktionen:
Funktion						Bedeutung
text()							Textinhalt eines Elements	
contains(@attribut, 'wert')		PrÃ¼ft, ob ein Attribut einen bestimmten Wert enthÃ¤lt
starts-with(@attribut, 'wert')	PrÃ¼ft, ob ein Attribut mit einem bestimmten Wert beginnt
normalize-space(text())			Entfernt Leerzeichen am Anfang und Ende
last()							Letztes Element einer Liste
position()						Gibt die Position eines Elements zurÃ¼ck
ğŸ“Œ Beispiele mit Funktionen:
XPath										Beschreibung
//div[contains(@class, 'header')]			<div> mit class, die "header" enthÃ¤lt
//a[starts-with(@href, 'https')]			<a>-Tags, deren href mit "https" beginnt
//li[position()=1]							Erstes <li>-Element
//ul/li[last()]								Letztes <li>-Element einer Liste
//p[normalize-space(text())='Hallo Welt']	<p>-Element mit genau "Hallo Welt"
ğŸ“Œ Achsen (Axes):
Mit Achsen navigierst du die Baumstruktur gezielt:
Achse	Beschreibung
child::							Kind-Elemente
parent::						Eltern-Element
ancestor::						Alle Vorfahren
descendant::					Alle Nachkommen
following::						Alle nachfolgenden Elemente
preceding::						Alle vorhergehenden Elemente
sibling::						Geschwister-Elemente
ğŸ”¸ Beispiel:
//div/child::span
â†’ Selektiert alle <span>-Kinder innerhalb eines <div>.

ğŸ“Œ XPath-Kombinationen:
Du kannst mehrere Bedingungen kombinieren:

//input[@type='text' and @name='username']
â†’ Findet ein Textfeld mit type="text" und name="username".

//button[@class='btn' or @id='submit']
â†’ Findet einen Button mit class="btn" ODER id="submit".


XPath Cheatsheet â€“ Schnellzugriff:

//div                          â†’ Alle `<div>`-Elemente  
//div[1]                       â†’ Erstes `<div>`-Element  
//*[@id='test']               â†’ Beliebiges Element mit `id="test"`  
//a[contains(text(), 'Login')] â†’ Link mit "Login" im Text  
//input[@type='checkbox']      â†’ Alle Checkboxen  
//ul/li[position()=last()]     â†’ Letztes `<li>` in einer Liste  


RegulÃ¤re AusdrÃ¼cke (Regex)
RegulÃ¤re AusdrÃ¼cke sind Muster, die zum Suchen und Manipulieren von Text verwendet werden. In XPath und CSS-Selektoren kÃ¶nnen sie helfen, gezielt Elemente auszuwÃ¤hlen, die bestimmten Textmustern entsprechen.

ğŸŸ¢ XPath mit regulÃ¤ren AusdrÃ¼cken
In XPath kannst du die Funktion contains(), starts-with(), oder sogar matches() nutzen:

xpath
Kopieren
Bearbeiten
//div[contains(@class, 'button')]
â¡ï¸ Findet alle <div>-Elemente, deren class-Attribut das Wort button enthÃ¤lt.

ğŸ”¸ Mit matches() fÃ¼r Regex (XPath 2.0+):

xpath
Kopieren
Bearbeiten
//input[matches(@name, '^user.*')]
â¡ï¸ Findet alle <input>-Elemente, bei denen der name mit â€userâ€œ beginnt.

ğŸŸ¡ CSS-Selektoren mit partiellen Ãœbereinstimmungen
CSS-Selektoren unterstÃ¼tzen keine vollen regulÃ¤ren AusdrÃ¼cke, aber sie haben Ã¤hnliche Syntax fÃ¼r Teilvergleiche:

^= â†’ beginnt mit
css
Kopieren
Bearbeiten
input[name^="user"]
â¡ï¸ WÃ¤hlt <input>-Felder aus, deren name mit "user" beginnt.

$= â†’ endet mit
css
Kopieren
Bearbeiten
a[href$=".pdf"]
â¡ï¸ WÃ¤hlt <a>-Links aus, die auf .pdf enden.

*= â†’ enthÃ¤lt
css
Kopieren
Bearbeiten
div[class*="error"]
â¡ï¸ WÃ¤hlt <div>-Elemente aus, deren class das Wort â€errorâ€œ irgendwo enthÃ¤lt.

ğŸ“Š XPath vs. CSS-Selektoren: Regex-FÃ¤higkeiten
XPath	CSS-Selektoren
Regex-UnterstÃ¼tzung	âœ… VollstÃ¤ndig (matches())	âŒ Keine echte Regex
Teilstringsuche	âœ… contains() & starts-with()	âœ… *=, ^=, $=
LeistungsfÃ¤higkeit	ğŸŸ¡ Flexibler, aber langsamer	ğŸŸ¢ Schneller, aber eingeschrÃ¤nkt
Wenn du komplexe Textmuster brauchst (z. B. E-Mail-Adressen), ist XPath mit matches() unschlagbar. FÃ¼r einfache Teilvergleiche sind CSS-Selektoren schneller.
