ğŸŸ© Grundlegende Selektoren

Selektor			Beschreibung						Beispiel

*					WÃ¤hlt alle Elemente					* { margin: 0; }
element				WÃ¤hlt alle Elemente dieses Typs		p { color: red; }
#id					WÃ¤hlt ein Element nach ID			#header { font-size: 20px; }
.class				WÃ¤hlt Elemente nach Klasse			.btn { background: blue; }
ğŸŸ¨ Kombinatoren

Selektor			Beschreibung						Beispiel

A B					Nachfahrenselektor (A â†’ B)			div p { color: green; }
A > B				Kindselektor (direkt)				div > p { color: blue; }
A + B				Adjazentselektor					h1 + p { margin-top: 10px; }
A ~ B				Geschwisterselektor					h1 ~ p { color: gray; }
ğŸŸ  Attributselektoren

Selektor			Beschreibung						Beispiel

[attribut]			Attribut vorhanden					[disabled] { opacity: 0.5; }
[attribut="wert"]	Genauer Wert						[type="text"] { color: black; }
[attribut~="wert"]	EnthÃ¤lt Wort						[class~="btn"] { padding: 10px; }
[attribut^="wert"]	Startet mit							[href^="https"] { color: green; }
[attribut$="wert"]	Endet mit	[						src$=".jpg"] { border: 1px solid; }
[attribut*="wert"]	EnthÃ¤lt Zeichenkette				[title*="Info"] { font-weight: bold; }
ğŸŸ¢ Pseudoklassen

Selektor			Beschreibung						Beispiel

:first-child		Erstes Kind							li:first-child { color: red; }
:last-child			Letztes Kind						li:last-child { color: blue; }
:nth-child(n)		Bestimmtes Kind						li:nth-child(2) { font-weight: bold; }
:hover				Hover-Effekt						a:hover { text-decoration: underline; }
:focus				Fokussiertes Element				input:focus { outline: none; }
:not(selector)		Negation							button:not(.disabled) { background: green; }
ğŸŸ£ Pseudoelemente

Selektor			Beschreibung						Beispiel

::before			FÃ¼gt Inhalt vor dem Element hinzu	p::before { content: "âœ¨ "; }
::after				FÃ¼gt Inhalt nach dem Element hinzu	p::after { content: " ğŸš€"; }
::first-letter		Stylt den ersten Buchstaben			p::first-letter { color: red; }
ğŸ“˜ Beispiel in Aktion
/* Allgemeine Styles */
body {
    font-family: Arial, sans-serif;
}

h1:hover {
    color: purple;
}

ul > li:first-child {
    font-weight: bold;
}

a[href^="https"] {
    color: green;
}

input:focus {
    border: 2px solid blue;
}


Was sind Kombinatoren?
Ein Kombinator ist ein Symbol, das beschreibt, wie zwei CSS-Selektoren miteinander in Beziehung stehen.

ğŸŸ© 1. Nachfahrenselektor ( - Leerzeichen)
WÃ¤hlt alle Nachfahren eines Elements (egal, wie tief verschachtelt)
div p {
    color: blue;
}
ğŸ”¸ Beispiel: Alle <p>-Elemente innerhalb eines <div> werden blau â€” egal, wie tief sie eingebettet sind!
<div>
    <p>Ich werde blau!</p>
    <section>
        <p>Ich auch, obwohl ich tiefer liege!</p>
    </section>
</div>
ğŸŸ¨ 2. Kindselektor (>)
WÃ¤hlt nur direkte Kinder eines Elements
div > p {
    color: red;
}
ğŸ”¸ Beispiel: Nur die direkten <p>-Elemente im <div> werden rot:
<div>
    <p>Ich werde rot!</p>
    <section>
        <p>Ich nicht, weil ich kein direktes Kind bin!</p>
    </section>
</div>
ğŸŸ  3. Adjazentselektor (+)
WÃ¤hlt das nÃ¤chste Geschwisterelement
h1 + p {
    font-size: 20px;
}
ğŸ”¸ Beispiel: Der erste <p> nach einem <h1> bekommt eine grÃ¶ÃŸere SchriftgrÃ¶ÃŸe:
<h1>Ãœberschrift</h1>
<p>Direkt daneben! Ich werde grÃ¶ÃŸer.</p>
<p>Ich nicht, weil ich nicht direkt daneben bin.</p>
ğŸŸ¢ 4. Geschwisterselektor (~)
WÃ¤hlt alle nachfolgenden Geschwisterelemente
h1 ~ p {
    color: green;
}
ğŸ”¸ Beispiel: Alle <p>-Elemente nach einem <h1> werden grÃ¼n:
<h1>Ãœberschrift</h1>
<p>Ich werde grÃ¼n!</p>
<p>Ich auch!</p>
ğŸ§  Zusammenfassung:
Selektor	Beschreibung			Beispiel
A B			WÃ¤hlt alle Nachfahren von A	div p
A > B		WÃ¤hlt direkte Kinder von A	div > p
A + B		WÃ¤hlt das nÃ¤chste Geschwisterelement	h1 + p
A ~ B		WÃ¤hlt alle Geschwisterelemente nach A	h1 ~ p
Kombinatoren sind supermÃ¤chtig, wenn du gezielt Elemente in einer komplexen HTML-Struktur stylen mÃ¶chtest â€” ganz ohne zusÃ¤tzliche Klassen oder IDs. ğŸ¯

In der Tabelle sind A und B Platzhalter fÃ¼r HTML-Elemente. Sie zeigen an, wie diese beiden Elemente zueinander in Beziehung stehen.

Ich erklÃ¤re es dir klarer:

ğŸŸ© A B (Nachfahrenselektor)
â¡ï¸ B ist ein Nachfahre von A, egal wie tief verschachtelt.
div p {
    color: blue;
}
ğŸ”¸ Bedeutung: Jedes <p>-Element innerhalb eines <div> wird blau.
ğŸ”¸ Egal wie tief verschachtelt das <p> ist!
<div>
    <p>Ich werde blau!</p>
    <section>
        <p>Ich auch, obwohl ich tiefer liege!</p>
    </section>
</div>
â¡ï¸ Beide <p>-Elemente werden blau, weil sie Nachfahren von <div> sind.

ğŸŸ¨ A > B (Kindselektor)
â¡ï¸ B ist ein direktes Kind von A.
div > p {
    color: red;
}
ğŸ”¸ Bedeutung: Nur <p>-Elemente, die direkt im <div> liegen, werden rot.
<div>
    <p>Ich werde rot!</p>
    <section>
        <p>Ich nicht, weil ich kein direktes Kind bin!</p>
    </section>
</div>
â¡ï¸ Nur das erste <p> wird rot, weil es ein direktes Kind von <div> ist.
â¡ï¸ Das zweite <p> ist kein direktes Kind, weil es in <section> liegt.

ğŸ”‘ Unterschied zusammengefasst:
Selektor				Bedeutung							Treffer
A B						Alle Nachfahren (egal wie tief)		Alle Kindelemente und Enkelkinder
A > B					Nur direkte Kinder					Nur direkt verschachtelte Elemente


RegulÃ¤re AusdrÃ¼cke (Regex)
RegulÃ¤re AusdrÃ¼cke sind Muster, die zum Suchen und Manipulieren von Text verwendet werden. In XPath und CSS-Selektoren kÃ¶nnen sie helfen, gezielt Elemente auszuwÃ¤hlen, die bestimmten Textmustern entsprechen.

ğŸŸ¢ XPath mit regulÃ¤ren AusdrÃ¼cken
In XPath kannst du die Funktion contains(), starts-with(), oder sogar
//div[contains(@class, 'button')]
â¡ï¸ Findet alle <div>-Elemente, deren class-Attribut das Wort button enthÃ¤lt.

ğŸ”¸ Mit matches() fÃ¼r Regex (XPath 2.0+):

//input[matches(@name, '^user.*')]
â¡ï¸ Findet alle <input>-Elemente, bei denen der name mit â€userâ€œ beginnt.

ğŸŸ¡ CSS-Selektoren mit partiellen Ãœbereinstimmungen
CSS-Selektoren unterstÃ¼tzen keine vollen regulÃ¤ren AusdrÃ¼cke, aber sie haben Ã¤hnliche Syntax fÃ¼r Teilvergleiche:

^= â†’ beginnt mit
input[name^="user"]
â¡ï¸ WÃ¤hlt <input>-Felder aus, deren name mit "user" beginnt.

$= â†’ endet mit
a[href$=".pdf"]
â¡ï¸ WÃ¤hlt <a>-Links aus, die auf .pdf enden.

*= â†’ enthÃ¤lt
div[class*="error"]
â¡ï¸ WÃ¤hlt <div>-Elemente aus, deren class das Wort â€errorâ€œ irgendwo enthÃ¤lt.

ğŸ“Š XPath vs. CSS-Selektoren: Regex-FÃ¤higkeiten
XPath	CSS-Selektoren
Regex-UnterstÃ¼tzung	âœ… VollstÃ¤ndig (matches())	âŒ Keine echte Regex
Teilstringsuche	âœ… contains() & starts-with()	âœ… *=, ^=, $=
LeistungsfÃ¤higkeit	ğŸŸ¡ Flexibler, aber langsamer	ğŸŸ¢ Schneller, aber eingeschrÃ¤nkt
Wenn du komplexe Textmuster brauchst (z. B. E-Mail-Adressen), ist XPath mit matches() unschlagbar. FÃ¼r einfache Teilvergleiche sind CSS-Selektoren schneller.

